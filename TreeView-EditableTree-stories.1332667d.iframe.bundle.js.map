{"version":3,"file":"TreeView-EditableTree-stories.1332667d.iframe.bundle.js","mappings":";;;;AA6DA;;;;;;;AAOA;AACA;;;;AAMA;;;;;;;;;;;;;ACmHA;;;;;AAOA;AACA;AAEA;;;;AAOA;;;;;;;;;ACzKA;;;AAGA;;;;AAKA","sources":["webpack://@toshusai/app-ui/./src/TreeView/DirectoryTreeItem.tsx","webpack://@toshusai/app-ui/./src/TreeView/EditableTree.tsx","webpack://@toshusai/app-ui/./src/TreeView/TreeItem.tsx"],"sourcesContent":["import React, { useState } from \"react\";\nimport styled from \"styled-components\";\n\nimport { NEST_SPACE, TreeItem, TreeViewItem } from \"./TreeItem\";\nimport { TreeView, WithTreeItemEvent } from \"./TreeView\";\nimport { useIsSelectedItem } from \"./useIsSelectedItem\";\n\nexport const DirectoryTreeItem = React.memo(function DirectoryTreeView<\n  U,\n  T extends TreeViewItem<U>\n>(props: {\n  item: T;\n  depth?: number;\n  renderItem: (item: T) => React.ReactNode;\n  onMouseDown?: WithTreeItemEvent<U, T>;\n  onMouseMove?: WithTreeItemEvent<U, T>;\n  onMouseUp?: WithTreeItemEvent<U, T>;\n  onClick?: WithTreeItemEvent<U, T>;\n}) {\n  const [open, setOpen] = useState(true);\n  const depth = props.depth ?? 0;\n  const isSelected = useIsSelectedItem(props.item);\n  return (\n    <TreeViewRootUl>\n      <TreeItem\n        depth={depth}\n        selected={isSelected}\n        onMouseDown={(e) => props.onMouseDown?.(props.item, e)}\n        onMouseMove={(e) => props.onMouseMove?.(props.item, e)}\n        onMouseUp={(e) => props.onMouseUp?.(props.item, e)}\n        onClick={(e) => props.onClick?.(props.item, e)}\n      >\n        {(props.item.children?.length ?? 0) > 0 ? (\n          <Button onClick={() => setOpen(!open)}>{open ? \"-\" : \"+\"}</Button>\n        ) : (\n          <Button style={{ visibility: \"hidden\" }}>-</Button>\n        )}\n        <PointerEventsNone>{props.renderItem(props.item)}</PointerEventsNone>\n      </TreeItem>\n      {open && (\n        <TreeView\n          depth={depth + 1}\n          items={props.item.children}\n          renderItem={props.renderItem as any}\n          onMouseMove={props.onMouseMove as any}\n          onMouseDown={props.onMouseDown as any}\n          onMouseUp={props.onMouseUp as any}\n          onClick={props.onClick as any}\n        />\n      )}\n    </TreeViewRootUl>\n  );\n});\n\nexport const PointerEventsNone = styled.div`\n  pointer-events: none;\n  display: flex;\n  width: calc(100% - 12px);\n`;\n\n\nconst Button = styled.button`\n  border: none;\n  background-color: transparent;\n  cursor: pointer;\n  padding: 0;\n  margin: 0;\n  color: var(--color-text);\n  width: ${NEST_SPACE}px;\n  min-width: ${NEST_SPACE}px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n`;\n\nconst TreeViewRootUl = styled.ul`\n  padding: 0;\n  margin: 0;\n\n  user-select: none;\n  width: 100%;\n`;\n","import React, { useEffect, useState } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport styled from \"styled-components\";\n\nimport { Key, KeyboardInput } from \"../KeyboardInput\";\nimport { useDragHandler } from \"../utils\";\nimport { TreeViewItem } from \"./TreeItem\";\nimport { TreeView } from \"./TreeView\";\nimport { checkPosType, checkPosType2, PosType } from \"./utils/checkPosType\";\nimport { SelectedItemsContext } from \"./SelectedItemsContext\";\n\nexport function EditableTree<U, T extends TreeViewItem<U>>(props: {\n  items?: T[];\n  renderItem: (item: T) => React.ReactNode;\n  depth?: number;\n  onOrderChange?: (start: T, end: T, pos: PosType) => void;\n  onChangeSelection?: (items: T[]) => void;\n  onClick?: (item: T) => void;\n  sortable?: boolean;\n}) {\n  const lineRef = React.useRef<HTMLDivElement>(null);\n  const [selectedItems, setSelectedItems] = useState<T[]>([]);\n  const [pos, setPos] = useState<PosType | null>(null);\n\n  const [dragging, setDragging] = useState(false);\n\n  useEffect(() => {\n    props.onChangeSelection?.(selectedItems);\n  }, [selectedItems]);\n\n  const handleMouseDown = useDragHandler(\n    (ctx) => {\n      setDragging(true);\n      const e = ctx.event;\n      e.preventDefault()\n      const tx = e.clientX;\n      const ty = e.clientY;\n      if (dragRef.current) {\n        dragRef.current.style.top = ty - 12 + \"px\";\n        dragRef.current.style.left = tx + \"px\";\n      }\n    },\n    undefined,\n    () => {\n      setDragging(false);\n    }\n  );\n\n  const handleMouseDownMemo = React.useCallback(\n    (item: T, e: React.MouseEvent<Element, MouseEvent>) => {\n      handleMouseDown(e);\n      if (KeyboardInput.isPressed(Key.Shift)) {\n        setSelectedItems((items) => {\n          return [...(items ?? []), item];\n        });\n      } else if (!selectedItems.find((i) => i.id === item.id)) {\n        setSelectedItems([item]);\n      }\n    },\n    [handleMouseDown, selectedItems]\n  );\n\n  const handleMouseMove = React.useCallback(\n    (item: T, e: React.MouseEvent<Element, MouseEvent>) => {\n      if (dragging) {\n        const posType =\n          item.children === undefined\n            ? checkPosType2(e.nativeEvent)\n            : checkPosType(e.nativeEvent);\n        const target = e.target as HTMLElement;\n        if (target.tagName === \"BUTTON\") return;\n        if (!ref.current?.contains(target)) {\n          return;\n        }\n        if (!props.sortable && posType === PosType.Top) return;\n        if (!props.sortable && posType === PosType.Bottom) return;\n        let top = 0;\n        if (posType === PosType.Top) {\n          top = target.offsetTop;\n        }\n        if (posType === PosType.Bottom) {\n          top = target.offsetTop + target.offsetHeight;\n        }\n        if (posType === PosType.Middle) {\n          top = target.offsetTop + target.offsetHeight / 2 - 6;\n        }\n        if (posType !== undefined) setPos(posType);\n        if (lineRef.current) {\n          lineRef.current.style.top = top + \"px\";\n          const style = getComputedStyle(target);\n          const pd = style.getPropertyValue(\"padding-left\");\n          const left = parseInt(pd.substring(0, pd.length - 2));\n          lineRef.current.style.marginLeft = left + \"px\";\n          lineRef.current.style.width = target.clientWidth - left + \"px\";\n          lineRef.current.style.visibility = \"visible\";\n        }\n      }\n    },\n    [dragging]\n  );\n\n  const handleMouseUpMemo = React.useCallback(\n    (item: T, e: React.MouseEvent<Element, MouseEvent>) => {\n      if (dragging) {\n        selectedItems.forEach((i) => {\n          props.onOrderChange?.(i, item, pos ?? PosType.Middle);\n        });\n      } else {\n        if (!KeyboardInput.isPressed(Key.Shift)) {\n          setSelectedItems([item]);\n        }\n      }\n      setDragging(false);\n      setPos(null);\n      lineRef.current?.style.setProperty(\"visibility\", \"hidden\");\n    },\n    [dragging, selectedItems, props, pos]\n  );\n\n  const handleMouseLeave = React.useCallback(() => {\n    setPos(null);\n    lineRef.current?.style.setProperty(\"visibility\", \"hidden\");\n  }, []);\n\n  const handleMouseEnter = React.useCallback(() => {\n    setPos(null);\n    if (dragging) {\n      lineRef.current?.style.setProperty(\"visibility\", \"visible\");\n    }\n  }, [dragging]);\n\n  const memoTreeView = React.useMemo(() => {\n    return (\n      <TreeView\n        items={props.items}\n        depth={props.depth}\n        renderItem={(item) => {\n          return props.renderItem(item as any);\n        }}\n        onMouseMove={handleMouseMove as any}\n        onMouseDown={handleMouseDownMemo as any}\n        onMouseUp={handleMouseUpMemo as any}\n      />\n    );\n  }, [\n    props,\n    handleMouseMove,\n    handleMouseDownMemo,\n    handleMouseUpMemo,\n    selectedItems,\n  ]);\n\n  const ref = React.useRef<HTMLDivElement>(null);\n  const dragRef = React.useRef<HTMLDivElement>(null);\n\n  return (\n    <>\n      <SelectedItemsContext.Provider value={selectedItems}>\n        <EditableTreeRoot\n          ref={ref}\n          onMouseLeave={handleMouseLeave}\n          onMouseEnter={handleMouseEnter}\n        >\n          <InsertionLine pos={pos ?? undefined} ref={lineRef} />\n          {memoTreeView}\n        </EditableTreeRoot>\n        {dragging &&\n          ReactDOM.createPortal(\n            <DragDiv ref={dragRef}>\n              {props.renderItem(selectedItems[0] as any)}\n              <div>\n                {selectedItems.length > 1 && `+${selectedItems.length - 1}`}\n              </div>\n            </DragDiv>,\n            document.body\n          )}\n      </SelectedItemsContext.Provider>\n    </>\n  );\n}\n\nconst DragDiv = styled.div`\n  position: absolute;\n  display: flex;\n  gap: 8px;\n  z-index: 1000;\n  pointer-events: none;\n  top: -9999px;\n`;\n\nconst InsertionLine = styled.div<{\n  pos?: PosType;\n}>`\n  display: flex;\n  position: absolute;\n  visibility: hidden;\n  width: 100%;\n  height: ${(props) => (props.pos === PosType.Middle ? \"12px\" : \"1px\")};\n  background-color: ${(props) =>\n    props.pos === PosType.Middle ? \"transparent\" : \"var(--color-primary)\"};\n  border: ${(props) =>\n    props.pos === PosType.Middle ? \"1px dashed var(--color-primary)\" : \"none\"};\n  z-index: 1000;\n  pointer-events: none;\n  transform: translateY(-1px);\n`;\n\nconst EditableTreeRoot = styled.div`\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n  overflow: hidden;\n`;\n","import React from \"react\";\nimport styled from \"styled-components\";\n\nimport { COLOR_FOCUS_NAME, COLOR_HOVER_NAME } from \"../GlobalStyle\";\n\nexport type TreeViewItem<T> = {\n  id: string;\n  children?: TreeViewItem<T>[];\n  data: T;\n};\n\nexport const NEST_SPACE = 6;\n\nexport function TreeItem<T>(\n  props: {\n    children: React.ReactNode;\n    depth?: number;\n    selected?: boolean;\n  } & Omit<React.HTMLAttributes<HTMLLIElement>, \"dangerouslySetInnerHTML\">\n) {\n  const { children, depth, ...rest } = props;\n  return (\n    <TreeItemRoot\n      selected={props.selected}\n      padding={props.depth ? props.depth * NEST_SPACE : 0}\n      {...rest}\n    >\n      {props.children}\n    </TreeItemRoot>\n  );\n}\n\nconst TreeItemRoot = styled.li<{\n  padding: number;\n  selected?: boolean;\n}>`\n  display: flex;\n  cursor: pointer;\n  padding-left: ${(props) => props.padding}px;\n  height: 12px;\n  line-height: 12px;\n  background-color: ${(props) =>\n    props.selected ? `var(${COLOR_FOCUS_NAME})` : \"transparent\"};\n  font-family: \"Roboto Mono\", monospace;\n\n  :hover {\n    background-color: ${(props) =>\n      props.selected ? `var(${COLOR_FOCUS_NAME})` : `var(${COLOR_HOVER_NAME})`};\n  }\n`;\n"],"names":[],"sourceRoot":""}